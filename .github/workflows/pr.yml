name: Lint and Test
on:
  pull_request:
    branches:
      - main
  push:
    branches:
      - main

permissions:
  contents: write
  statuses: write
  checks: write
  pull-requests: write

jobs:
  set-version-tag:
    runs-on: ubuntu-24.04
    outputs:
      semVer: ${{ steps.gitversion.outputs.semVer }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Install GitVersion
        uses: gittools/actions/gitversion/setup@v3.0
        with:
          versionSpec: '5.x'
      - name: Set SemVer Version
        uses: gittools/actions/gitversion/execute@v3.0
        id: gitversion
  # Runs in parallel
  lint:
    name: Lint
    runs-on: ubuntu-24.04
    env:
      DOCKER_HOST: unix:///var/run/docker.sock
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: 1.25.x
      - name: Linters
        run: |
          go run -race cmd/main.go run lints

  test:
    name: Test
    runs-on: ubuntu-24.04
    needs:
      - set-version-tag
      - lint
    env:
      SEMVER: ${{ needs.set-version-tag.outputs.semVer }}
      DOCKER_HOST: unix:///var/run/docker.sock
    steps:
    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: 1.25.x

    - name: Check out code into the Go module directory
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        

    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-

    - name: check schema
      run: |
        CI=true go run cmd/main.go generate_own_schema

    - name: Test
      run: |
        go run cmd/main.go run pipeline test:unit

    - name: Publish Junit style Test Report
      uses: mikepenz/action-junit-report@v5
      if: always() # always run even if the previous step fails
      with:
        report_paths: '.coverage/report-junit.xml'
        commit: ${{ github.sha }}
        fail_on_failure: true
        check_name: Eirctl Unit Tests


    - name: Verify git history for SonarCloud
      run: |
        echo "=== Git Repository Information ==="
        echo "Git repository state:"
        if [ -f ".git/shallow" ]; then
          echo "⚠️ Repository is shallow - this will cause SonarCloud warnings"
          echo "Shallow file contents:"
          cat .git/shallow
        else
          echo "✓ Repository is not shallow"
        fi
        echo "Git log count: $(git log --oneline | wc -l)"
        echo "Git branch: $(git branch --show-current)"
        echo "Git remote: $(git remote -v)"
        echo "Recent commits:"
        git log --oneline -10
        echo ""
        
    - name: Debug coverage files
      run: |
        echo "=== Coverage Files ==="
        ls -la .coverage/ || echo "No .coverage directory found"
        if [ -f ".coverage/out" ]; then
          echo "Native Go coverage file exists ($(wc -l < .coverage/out) lines)"
          echo "File size: $(stat -c%s .coverage/out) bytes"
          echo "First few lines:"
          head -10 .coverage/out
          echo "Checking for coverage data:"
          if head -1 .coverage/out | grep -q "^mode:"; then
            echo "✓ Contains valid Go coverage format"
            echo "Coverage mode: $(head -1 .coverage/out)"
            covered_lines=$(grep -c " [1-9]" .coverage/out)
            total_lines=$(tail -n +2 .coverage/out | wc -l)
            echo "Coverage stats: $covered_lines covered lines out of $total_lines total lines"
          else
            echo "✗ Invalid Go coverage format (should start with 'mode:')"
          fi
        else
          echo "Native Go coverage file (.coverage/out) not found"
        fi
        if [ -f ".coverage/report-junit.xml" ]; then
          echo "JUnit report exists ($(wc -l < .coverage/report-junit.xml) lines)"
          echo "File size: $(stat -c%s .coverage/report-junit.xml) bytes"
          if grep -q "<testsuite" .coverage/report-junit.xml; then
            echo "✓ Contains test data"
          else
            echo "✗ No test data found"
          fi
        else
          echo "JUnit report not found"
        fi
        echo ""
        echo "=== SonarCloud Configuration ==="
        echo "Project base directory: $(pwd)"
        echo "Checking sonar-project.properties:"
        if [ -f "sonar-project.properties" ]; then
          echo "✓ sonar-project.properties exists"
          echo "Key settings:"
          grep -E "(sonar.projectKey|sonar.organization|sonar.go.coverage.reportPaths)" sonar-project.properties || echo "No matching properties found"
        else
          echo "✗ sonar-project.properties not found"
        fi

    - name: Ensure full git history for SonarCloud
      run: |
        echo "Ensuring full git history is available for SonarCloud..."
        # Check if repository is shallow and unshallow if needed
        if [ -f ".git/shallow" ]; then
          echo "Repository is shallow, running git fetch --unshallow..."
          git fetch --unshallow
          echo "Git unshallow completed"
        else
          echo "Repository already has full history"
        fi
        # Verify we have adequate history
        commit_count=$(git log --oneline | wc -l)
        echo "Total commits available: $commit_count"
        if [ "$commit_count" -lt 10 ]; then
          echo "⚠️ Warning: Only $commit_count commits available, this may affect SonarCloud SCM features"
        else
          echo "✓ Sufficient git history available for SonarCloud"
        fi

    - name: Analyze with SonarCloud
      uses: SonarSource/sonarqube-scan-action@v6
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Needed to get PR information
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}   # Generate a token on Sonarcloud.io, add it to the secrets of this repo with the name SONAR_TOKEN (Settings > Secrets > Actions > add new repository secret)
        SONAR_HOST_URL: https://sonarcloud.io
      with:
        projectBaseDir: .
        args: >
          -Dsonar.projectVersion=${{ needs.set-version-tag.outputs.semVer }}
